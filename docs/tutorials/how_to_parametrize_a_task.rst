How to parametrize a task
=========================

Often, you want to define a task which should be repeated over a range of inputs. pytask
allows to parametrize task functions to accomplish this behavior.

A simple example
----------------

Let us focus on a simple example. In this setting, we want to define a task which
receives a number and saves it to a file. And, this task should be repeated for the
numbers from 0 to 4.

First, we write the task for one number.

.. code-block:: python

    import pytask


    @pytask.mark.produces("0.txt")
    def task_save_number(produces, i=0):
        produces.write_text(str(i))

In the next step, we parametrize the task by varying ``i``.

.. code-block:: python

    import pytask


    @pytask.mark.parametrize("produces, i", [(f"{i}.txt", i) for i in range(5)])
    def task_save_number(produces, i):
        produces.write_text(str(i))

The parametrize decorator receives two arguments. The first argument is the signature
which defines the names of the elements in the second argument. ``"produces, i"``
indicates that the second argument is an iterable with two elements.

The names in the signature can be passed in three different formats which are explained
:ref:`below <parametrize_signature>`. Here we use a comma-separated string. Thus, the
first argument is called ``"produces"`` and the second ``"i"``.

The second argument of the parametrize decorator is the iterable. Each entry in the list
has to provide one value for each argument name in the signature. In the example, the
iterable is constructed by a list comprehension which expands to

.. ipython::

    In [1]: from pathlib import Path

    In [2]: [(Path(f"{i}.txt"), i) for i in range(5)]

Putting all together, the task is run five times and each run the path from the list is
mapped to the argument ``produces`` and ``i`` receives the number.

.. important::

    If you use ``produces`` or ``depends_on`` in the signature of the parametrize
    decorator, the values are automatically treated as if they were attached to the
    function with ``@pytask.mark.depends_on`` or ``@pytask.mark.produces``. For
    example, the generated task in which ``i = 1`` is identical to

    .. code-block:: python

        @pytask.mark.produces("1.txt")
        def task_save_number(produces, i=1):
            produces.write_text(str(i))


Optional usage of dependencies and products in function
-------------------------------------------------------

The previous task used ``produces`` as a function argument which is not strictly
necessary as the file name could be generated by using only ``i``. Thus, the following
example is equivalent to the former example.

.. code-block:: python

    from pathlib import Path


    @pytask.mark.parametrize("produces, i", [(f"{i}.txt", i) for i in range(5)])
    def task_save_number(i):
        Path(__file__).parent.joinpath(f"{i}.txt").write_text(str(i))

.. important::

    This example illustrates that it is only important to use ``"produces"`` and
    ``depends_on`` as well inside the signature to make pytask aware that the task
    produces or depends on a file. It is not necessary to use the argument inside
    the function.


Un-parametrized dependencies
----------------------------

It is also possible to combine ``@pytask.mark.parametrize`` with
``@pytask.mark.depends_on`` to specify a dependency which is the same for all generated
tasks.

In the following example, we read the content from a dependency which is the same for
all generated tasks and save it along a generated number to a file.

.. code-block:: python

    @pytask.mark.depends_on(Path("additional_text.txt"))
    @pytask.mark.parametrize("produces, i", [(f"{i}.txt", i) for i in range(5)])
    def task_save_number(depends_on, produces, i):
        additional_text = depends_on.read_text()
        produces.write_text(additional_text + str(i))


.. _parametrize_signature:

The signature
-------------

The signature can be passed in three different formats.

1. The signature can be a comma-separated string like an entry in a csv table. Note that
   white-space is stripped from each name which you can use to separate the names for
   readability. Here are some examples:

   .. code-block:: python

       "single_argument"
       "first_argument,second_argument"
       "first_argument, second_argument"

2. The signature can be a tuple of strings where each string is one argument name. Here
   is an example.

   .. code-block:: python

       ("first_argument", "second_argument")

3. Finally, it is also possible to use a list of strings.

   .. code-block:: python

       ["first_argument", "second_argument"]
