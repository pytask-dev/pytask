How to parametrize a task
=========================

Often times, you define a task which should be repeated over a range of inputs. Just
like pytest, pytask has a parametrize decorator for this reason.

Since pytask needs to track dependencies and products of tasks, there is a little bit
more logic bound to the parametrize decorator which is explained in this section.


A simple example
----------------

Let us focus on a simple example. In this setting, we want to define a task which
receives a number and saves it to a file. And, this task should be done for the numbers
from 0 to 4.

First, we write the task for one number.

.. code-block:: python

    import pytask
    from pathlib import Path


    @pytask.mark.produces(Path("0.txt"))
    def task_save_number(produces, i=0):
        produces.write_text(str(i))

In the next step, we parametrize the task.

.. code-block:: python

    import pytask
    from pathlib import pathlib


    @pytask.mark.parametrize("produces, i", [(Path(f"{i}.txt"), i) for i in range(5)])
    def task_save_number(produces, i):
        produces.write_text(str(i))

The parametrize decorator receives two arguments. The first argument is the signature
which defines the names of the elements in the second argument which is a list.

The names in the signature can be passed in three different formats which are explained
:ref:`below <parametrize_signature>`. Here we use a comma-separated string. Thus, the
first argument is called ``"produces"`` and the second ``"i"``.

The second argument of the parametrize decorator is the iterable which is a list. Each
entry in the list has to provide one value for each argument name in the signature. In
the example, the iterable is constructed by a list comprehension which expands to

.. ipython::

    In [1]: from pathlib import Path

    In [2]: [(Path(f"{i}.txt"), i) for i in range(5)]

Putting all together, the task is run five times and each run the path from the list is
mapped to the argument ``produces`` and ``i`` receives the number.

.. important::

    If you use ``produces`` or ``depends_on`` in the signature of the parametrize
    decorator, the values are automatically treated as if they were added with the
    ``@pytask.mark.depends_on`` or ``@pytask.mark.produces``. For example, the iteration
    of the task in which ``i = 1`` is the same as

    .. code-block:: python

        @pytask.mark.produces(Path("1.txt"))
        def task_save_number(produces, i=1):
            produces.write_text(str(i))


Optional usage of dependencies and products in function
-------------------------------------------------------

The previous task used ``produces`` as a function argument which is not strictly
necessary as the file name could be generated by using only ``i``. Thus, the following
example is equivalent to the former example.

.. code-block:: python

    @pytask.mark.parametrize("produces, i", [(Path(f"{i}.txt"), i) for i in range(5)])
    def task_save_number(i):
        Path(__file__).parent.joinpath(f"{i}.txt").write_text(str(i))

.. important::

    This example illustrates that it is only important to use ``"produces"`` inside the
    signature to make pytask aware that the task produces a file. It is not necessary to
    use the argument as an argument to the function.


Un-parametrized dependencies
----------------------------

It is also possible to combine ``@pytask.mark.parametrize`` with
``@pytask.mark.depends_on`` to specify a dependency which is the same for all generated
tasks.

In the following example, we read the content from a dependency which is the same for
all generated tasks and save it along a generated number to a file.

.. code-block:: python

    @pytask.mark.depends_on(Path("additional_text.txt"))
    @pytask.mark.parametrize("produces, i", [(Path(f"{i}.txt"), i) for i in range(5)])
    def task_save_number(depends_on, produces, i):
        additional_text = depends_on.read_text()
        produces.write_text(additional_text + str(i))


.. _parametrize_signature:

The signature
-------------

The signature can be passed in three different formats.

1. The signature can be a comma-separated string like an entry in a csv table. Note that
   white-space is stripped from each name which you can use to separate the names for
   readability. Here are some examples:

   .. code-block:: python

       "single_argument"
       "first_argument,second_argument"
       "first_argument, second_argument"

2. The signature can be a tuple of strings where each string is one argument name. Here
   is an example.

   .. code-block:: python

       ("first_argument", "second_argument")

3. Finally, it is also possible to use a list of strings.

   .. code-block:: python

       ["first_argument", "second_argument"]
